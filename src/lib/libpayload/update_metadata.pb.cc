// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: update_metadata.proto

#include "payload/update_metadata.pb.h"

#include <algorithm>
#include <cstdint>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace chromeos_update_engine {
PROTOBUF_CONSTEXPR Extent::Extent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.start_block_)*/::uint64_t{0u}
  , /*decltype(_impl_.num_blocks_)*/::uint64_t{0u}} {}
struct ExtentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExtentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExtentDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    Extent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtentDefaultTypeInternal _Extent_default_instance_;
PROTOBUF_CONSTEXPR Signatures_Signature::Signatures_Signature(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/0u
  , /*decltype(_impl_.unpadded_signature_size_)*/0u} {}
struct Signatures_SignatureDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Signatures_SignatureDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Signatures_SignatureDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    Signatures_Signature _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Signatures_SignatureDefaultTypeInternal _Signatures_Signature_default_instance_;
PROTOBUF_CONSTEXPR Signatures::Signatures(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.signatures_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SignaturesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignaturesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignaturesDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    Signatures _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignaturesDefaultTypeInternal _Signatures_default_instance_;
PROTOBUF_CONSTEXPR PartitionInfo::PartitionInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.size_)*/::uint64_t{0u}} {}
struct PartitionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PartitionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PartitionInfoDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    PartitionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PartitionInfoDefaultTypeInternal _PartitionInfo_default_instance_;
PROTOBUF_CONSTEXPR InstallOperation::InstallOperation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.src_extents_)*/{}
  , /*decltype(_impl_.dst_extents_)*/{}
  , /*decltype(_impl_.data_sha256_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.src_sha256_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.data_offset_)*/::uint64_t{0u}
  , /*decltype(_impl_.data_length_)*/::uint64_t{0u}
  , /*decltype(_impl_.src_length_)*/::uint64_t{0u}
  , /*decltype(_impl_.dst_length_)*/::uint64_t{0u}
  , /*decltype(_impl_.type_)*/0} {}
struct InstallOperationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InstallOperationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InstallOperationDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    InstallOperation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InstallOperationDefaultTypeInternal _InstallOperation_default_instance_;
PROTOBUF_CONSTEXPR CowMergeOperation::CowMergeOperation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.src_extent_)*/nullptr
  , /*decltype(_impl_.dst_extent_)*/nullptr
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.src_offset_)*/0u} {}
struct CowMergeOperationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CowMergeOperationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CowMergeOperationDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    CowMergeOperation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CowMergeOperationDefaultTypeInternal _CowMergeOperation_default_instance_;
PROTOBUF_CONSTEXPR PartitionUpdate::PartitionUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.new_partition_signature_)*/{}
  , /*decltype(_impl_.operations_)*/{}
  , /*decltype(_impl_.merge_operations_)*/{}
  , /*decltype(_impl_.partition_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.postinstall_path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.filesystem_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hash_tree_algorithm_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hash_tree_salt_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.old_partition_info_)*/nullptr
  , /*decltype(_impl_.new_partition_info_)*/nullptr
  , /*decltype(_impl_.hash_tree_data_extent_)*/nullptr
  , /*decltype(_impl_.hash_tree_extent_)*/nullptr
  , /*decltype(_impl_.fec_data_extent_)*/nullptr
  , /*decltype(_impl_.fec_extent_)*/nullptr
  , /*decltype(_impl_.estimate_cow_size_)*/::uint64_t{0u}
  , /*decltype(_impl_.estimate_op_count_max_)*/::uint64_t{0u}
  , /*decltype(_impl_.run_postinstall_)*/false
  , /*decltype(_impl_.postinstall_optional_)*/false
  , /*decltype(_impl_.fec_roots_)*/2u} {}
struct PartitionUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PartitionUpdateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PartitionUpdateDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    PartitionUpdate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PartitionUpdateDefaultTypeInternal _PartitionUpdate_default_instance_;
PROTOBUF_CONSTEXPR DynamicPartitionGroup::DynamicPartitionGroup(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.partition_names_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.size_)*/::uint64_t{0u}} {}
struct DynamicPartitionGroupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DynamicPartitionGroupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DynamicPartitionGroupDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    DynamicPartitionGroup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DynamicPartitionGroupDefaultTypeInternal _DynamicPartitionGroup_default_instance_;
PROTOBUF_CONSTEXPR VABCFeatureSet::VABCFeatureSet(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.threaded_)*/false
  , /*decltype(_impl_.batch_writes_)*/false} {}
struct VABCFeatureSetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VABCFeatureSetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VABCFeatureSetDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    VABCFeatureSet _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VABCFeatureSetDefaultTypeInternal _VABCFeatureSet_default_instance_;
PROTOBUF_CONSTEXPR DynamicPartitionMetadata::DynamicPartitionMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.groups_)*/{}
  , /*decltype(_impl_.vabc_compression_param_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.vabc_feature_set_)*/nullptr
  , /*decltype(_impl_.snapshot_enabled_)*/false
  , /*decltype(_impl_.vabc_enabled_)*/false
  , /*decltype(_impl_.cow_version_)*/0u
  , /*decltype(_impl_.compression_factor_)*/::uint64_t{0u}} {}
struct DynamicPartitionMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DynamicPartitionMetadataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DynamicPartitionMetadataDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    DynamicPartitionMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DynamicPartitionMetadataDefaultTypeInternal _DynamicPartitionMetadata_default_instance_;
PROTOBUF_CONSTEXPR ApexInfo::ApexInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.package_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/::int64_t{0}
  , /*decltype(_impl_.decompressed_size_)*/::int64_t{0}
  , /*decltype(_impl_.is_compressed_)*/false} {}
struct ApexInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApexInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApexInfoDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    ApexInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApexInfoDefaultTypeInternal _ApexInfo_default_instance_;
PROTOBUF_CONSTEXPR ApexMetadata::ApexMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.apex_info_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ApexMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApexMetadataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApexMetadataDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    ApexMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApexMetadataDefaultTypeInternal _ApexMetadata_default_instance_;
PROTOBUF_CONSTEXPR DeltaArchiveManifest::DeltaArchiveManifest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.partitions_)*/{}
  , /*decltype(_impl_.apex_info_)*/{}
  , /*decltype(_impl_.security_patch_level_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dynamic_partition_metadata_)*/nullptr
  , /*decltype(_impl_.signatures_offset_)*/::uint64_t{0u}
  , /*decltype(_impl_.signatures_size_)*/::uint64_t{0u}
  , /*decltype(_impl_.max_timestamp_)*/::int64_t{0}
  , /*decltype(_impl_.minor_version_)*/0u
  , /*decltype(_impl_.partial_update_)*/false
  , /*decltype(_impl_.block_size_)*/4096u} {}
struct DeltaArchiveManifestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeltaArchiveManifestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeltaArchiveManifestDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    DeltaArchiveManifest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeltaArchiveManifestDefaultTypeInternal _DeltaArchiveManifest_default_instance_;
}  // namespace chromeos_update_engine
static ::_pb::Metadata file_level_metadata_update_5fmetadata_2eproto[13];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_update_5fmetadata_2eproto[2];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_update_5fmetadata_2eproto = nullptr;

const ::uint32_t TableStruct_update_5fmetadata_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Extent, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Extent, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Extent, _impl_.start_block_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Extent, _impl_.num_blocks_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Signatures_Signature, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Signatures_Signature, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Signatures_Signature, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Signatures_Signature, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Signatures_Signature, _impl_.unpadded_signature_size_),
  1,
  0,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Signatures, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::Signatures, _impl_.signatures_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionInfo, _impl_.size_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionInfo, _impl_.hash_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, _impl_.data_offset_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, _impl_.data_length_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, _impl_.src_extents_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, _impl_.src_length_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, _impl_.dst_extents_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, _impl_.dst_length_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, _impl_.data_sha256_hash_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::InstallOperation, _impl_.src_sha256_hash_),
  6,
  2,
  3,
  ~0u,
  4,
  ~0u,
  5,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::CowMergeOperation, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::CowMergeOperation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::CowMergeOperation, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::CowMergeOperation, _impl_.src_extent_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::CowMergeOperation, _impl_.dst_extent_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::CowMergeOperation, _impl_.src_offset_),
  2,
  0,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _impl_.partition_name_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _impl_.run_postinstall_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _impl_.postinstall_path_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _impl_.filesystem_type_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _impl_.new_partition_signature_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _impl_.old_partition_info_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _impl_.new_partition_info_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _impl_.operations_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _impl_.postinstall_optional_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _impl_.hash_tree_data_extent_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _impl_.hash_tree_extent_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _impl_.hash_tree_algorithm_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _impl_.hash_tree_salt_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _impl_.fec_data_extent_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _impl_.fec_extent_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _impl_.fec_roots_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _impl_.merge_operations_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _impl_.estimate_cow_size_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::PartitionUpdate, _impl_.estimate_op_count_max_),
  0,
  14,
  1,
  2,
  ~0u,
  6,
  7,
  ~0u,
  15,
  8,
  9,
  3,
  4,
  10,
  11,
  16,
  5,
  ~0u,
  12,
  13,
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionGroup, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionGroup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionGroup, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionGroup, _impl_.size_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionGroup, _impl_.partition_names_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::VABCFeatureSet, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::VABCFeatureSet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::VABCFeatureSet, _impl_.threaded_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::VABCFeatureSet, _impl_.batch_writes_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionMetadata, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionMetadata, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionMetadata, _impl_.groups_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionMetadata, _impl_.snapshot_enabled_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionMetadata, _impl_.vabc_enabled_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionMetadata, _impl_.vabc_compression_param_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionMetadata, _impl_.cow_version_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionMetadata, _impl_.vabc_feature_set_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DynamicPartitionMetadata, _impl_.compression_factor_),
  ~0u,
  2,
  3,
  0,
  4,
  1,
  5,
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::ApexInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::ApexInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::ApexInfo, _impl_.package_name_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::ApexInfo, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::ApexInfo, _impl_.is_compressed_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::ApexInfo, _impl_.decompressed_size_),
  0,
  1,
  3,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::ApexMetadata, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::ApexMetadata, _impl_.apex_info_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, _impl_.block_size_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, _impl_.signatures_offset_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, _impl_.signatures_size_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, _impl_.minor_version_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, _impl_.partitions_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, _impl_.max_timestamp_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, _impl_.dynamic_partition_metadata_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, _impl_.partial_update_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, _impl_.apex_info_),
  PROTOBUF_FIELD_OFFSET(::chromeos_update_engine::DeltaArchiveManifest, _impl_.security_patch_level_),
  7,
  2,
  3,
  5,
  ~0u,
  4,
  1,
  6,
  ~0u,
  0,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::chromeos_update_engine::Extent)},
  { 10, 19, -1, sizeof(::chromeos_update_engine::Signatures_Signature)},
  { 22, -1, -1, sizeof(::chromeos_update_engine::Signatures)},
  { 29, 37, -1, sizeof(::chromeos_update_engine::PartitionInfo)},
  { 39, 54, -1, sizeof(::chromeos_update_engine::InstallOperation)},
  { 63, 73, -1, sizeof(::chromeos_update_engine::CowMergeOperation)},
  { 77, 103, -1, sizeof(::chromeos_update_engine::PartitionUpdate)},
  { 123, 132, -1, sizeof(::chromeos_update_engine::DynamicPartitionGroup)},
  { 135, 143, -1, sizeof(::chromeos_update_engine::VABCFeatureSet)},
  { 145, 158, -1, sizeof(::chromeos_update_engine::DynamicPartitionMetadata)},
  { 165, 175, -1, sizeof(::chromeos_update_engine::ApexInfo)},
  { 179, -1, -1, sizeof(::chromeos_update_engine::ApexMetadata)},
  { 186, 202, -1, sizeof(::chromeos_update_engine::DeltaArchiveManifest)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::chromeos_update_engine::_Extent_default_instance_._instance,
  &::chromeos_update_engine::_Signatures_Signature_default_instance_._instance,
  &::chromeos_update_engine::_Signatures_default_instance_._instance,
  &::chromeos_update_engine::_PartitionInfo_default_instance_._instance,
  &::chromeos_update_engine::_InstallOperation_default_instance_._instance,
  &::chromeos_update_engine::_CowMergeOperation_default_instance_._instance,
  &::chromeos_update_engine::_PartitionUpdate_default_instance_._instance,
  &::chromeos_update_engine::_DynamicPartitionGroup_default_instance_._instance,
  &::chromeos_update_engine::_VABCFeatureSet_default_instance_._instance,
  &::chromeos_update_engine::_DynamicPartitionMetadata_default_instance_._instance,
  &::chromeos_update_engine::_ApexInfo_default_instance_._instance,
  &::chromeos_update_engine::_ApexMetadata_default_instance_._instance,
  &::chromeos_update_engine::_DeltaArchiveManifest_default_instance_._instance,
};

const char descriptor_table_protodef_update_5fmetadata_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\025update_metadata.proto\022\026chromeos_update"
  "_engine\"1\n\006Extent\022\023\n\013start_block\030\001 \001(\004\022\022"
  "\n\nnum_blocks\030\002 \001(\004\"\237\001\n\nSignatures\022@\n\nsig"
  "natures\030\001 \003(\0132,.chromeos_update_engine.S"
  "ignatures.Signature\032O\n\tSignature\022\023\n\007vers"
  "ion\030\001 \001(\rB\002\030\001\022\014\n\004data\030\002 \001(\014\022\037\n\027unpadded_"
  "signature_size\030\003 \001(\007\"+\n\rPartitionInfo\022\014\n"
  "\004size\030\001 \001(\004\022\014\n\004hash\030\002 \001(\014\"\270\004\n\020InstallOpe"
  "ration\022;\n\004type\030\001 \002(\0162-.chromeos_update_e"
  "ngine.InstallOperation.Type\022\023\n\013data_offs"
  "et\030\002 \001(\004\022\023\n\013data_length\030\003 \001(\004\0223\n\013src_ext"
  "ents\030\004 \003(\0132\036.chromeos_update_engine.Exte"
  "nt\022\022\n\nsrc_length\030\005 \001(\004\0223\n\013dst_extents\030\006 "
  "\003(\0132\036.chromeos_update_engine.Extent\022\022\n\nd"
  "st_length\030\007 \001(\004\022\030\n\020data_sha256_hash\030\010 \001("
  "\014\022\027\n\017src_sha256_hash\030\t \001(\014\"\367\001\n\004Type\022\013\n\007R"
  "EPLACE\020\000\022\016\n\nREPLACE_BZ\020\001\022\014\n\004MOVE\020\002\032\002\010\001\022\016"
  "\n\006BSDIFF\020\003\032\002\010\001\022\017\n\013SOURCE_COPY\020\004\022\021\n\rSOURC"
  "E_BSDIFF\020\005\022\016\n\nREPLACE_XZ\020\010\022\010\n\004ZERO\020\006\022\013\n\007"
  "DISCARD\020\007\022\021\n\rBROTLI_BSDIFF\020\n\022\014\n\010PUFFDIFF"
  "\020\t\022\014\n\010ZUCCHINI\020\013\022\022\n\016LZ4DIFF_BSDIFF\020\014\022\024\n\020"
  "LZ4DIFF_PUFFDIFF\020\r\022\020\n\014REPLACE_ZSTD\020\016\"\201\002\n"
  "\021CowMergeOperation\022<\n\004type\030\001 \001(\0162..chrom"
  "eos_update_engine.CowMergeOperation.Type"
  "\0222\n\nsrc_extent\030\002 \001(\0132\036.chromeos_update_e"
  "ngine.Extent\0222\n\ndst_extent\030\003 \001(\0132\036.chrom"
  "eos_update_engine.Extent\022\022\n\nsrc_offset\030\004"
  " \001(\r\"2\n\004Type\022\014\n\010COW_COPY\020\000\022\013\n\007COW_XOR\020\001\022"
  "\017\n\013COW_REPLACE\020\002\"\347\006\n\017PartitionUpdate\022\026\n\016"
  "partition_name\030\001 \002(\t\022\027\n\017run_postinstall\030"
  "\002 \001(\010\022\030\n\020postinstall_path\030\003 \001(\t\022\027\n\017files"
  "ystem_type\030\004 \001(\t\022M\n\027new_partition_signat"
  "ure\030\005 \003(\0132,.chromeos_update_engine.Signa"
  "tures.Signature\022A\n\022old_partition_info\030\006 "
  "\001(\0132%.chromeos_update_engine.PartitionIn"
  "fo\022A\n\022new_partition_info\030\007 \001(\0132%.chromeo"
  "s_update_engine.PartitionInfo\022<\n\noperati"
  "ons\030\010 \003(\0132(.chromeos_update_engine.Insta"
  "llOperation\022\034\n\024postinstall_optional\030\t \001("
  "\010\022=\n\025hash_tree_data_extent\030\n \001(\0132\036.chrom"
  "eos_update_engine.Extent\0228\n\020hash_tree_ex"
  "tent\030\013 \001(\0132\036.chromeos_update_engine.Exte"
  "nt\022\033\n\023hash_tree_algorithm\030\014 \001(\t\022\026\n\016hash_"
  "tree_salt\030\r \001(\014\0227\n\017fec_data_extent\030\016 \001(\013"
  "2\036.chromeos_update_engine.Extent\0222\n\nfec_"
  "extent\030\017 \001(\0132\036.chromeos_update_engine.Ex"
  "tent\022\024\n\tfec_roots\030\020 \001(\r:\0012\022\017\n\007version\030\021 "
  "\001(\t\022C\n\020merge_operations\030\022 \003(\0132).chromeos"
  "_update_engine.CowMergeOperation\022\031\n\021esti"
  "mate_cow_size\030\023 \001(\004\022\035\n\025estimate_op_count"
  "_max\030\024 \001(\004\"L\n\025DynamicPartitionGroup\022\014\n\004n"
  "ame\030\001 \002(\t\022\014\n\004size\030\002 \001(\004\022\027\n\017partition_nam"
  "es\030\003 \003(\t\"8\n\016VABCFeatureSet\022\020\n\010threaded\030\001"
  " \001(\010\022\024\n\014batch_writes\030\002 \001(\010\"\234\002\n\030DynamicPa"
  "rtitionMetadata\022=\n\006groups\030\001 \003(\0132-.chrome"
  "os_update_engine.DynamicPartitionGroup\022\030"
  "\n\020snapshot_enabled\030\002 \001(\010\022\024\n\014vabc_enabled"
  "\030\003 \001(\010\022\036\n\026vabc_compression_param\030\004 \001(\t\022\023"
  "\n\013cow_version\030\005 \001(\r\022@\n\020vabc_feature_set\030"
  "\006 \001(\0132&.chromeos_update_engine.VABCFeatu"
  "reSet\022\032\n\022compression_factor\030\007 \001(\004\"c\n\010Ape"
  "xInfo\022\024\n\014package_name\030\001 \001(\t\022\017\n\007version\030\002"
  " \001(\003\022\025\n\ris_compressed\030\003 \001(\010\022\031\n\021decompres"
  "sed_size\030\004 \001(\003\"C\n\014ApexMetadata\0223\n\tapex_i"
  "nfo\030\001 \003(\0132 .chromeos_update_engine.ApexI"
  "nfo\"\303\003\n\024DeltaArchiveManifest\022\030\n\nblock_si"
  "ze\030\003 \001(\r:\0044096\022\031\n\021signatures_offset\030\004 \001("
  "\004\022\027\n\017signatures_size\030\005 \001(\004\022\030\n\rminor_vers"
  "ion\030\014 \001(\r:\0010\022;\n\npartitions\030\r \003(\0132\'.chrom"
  "eos_update_engine.PartitionUpdate\022\025\n\rmax"
  "_timestamp\030\016 \001(\003\022T\n\032dynamic_partition_me"
  "tadata\030\017 \001(\01320.chromeos_update_engine.Dy"
  "namicPartitionMetadata\022\026\n\016partial_update"
  "\030\020 \001(\010\0223\n\tapex_info\030\021 \003(\0132 .chromeos_upd"
  "ate_engine.ApexInfo\022\034\n\024security_patch_le"
  "vel\030\022 \001(\tJ\004\010\001\020\002J\004\010\002\020\003J\004\010\006\020\007J\004\010\007\020\010J\004\010\010\020\tJ"
  "\004\010\t\020\nJ\004\010\n\020\013J\004\010\013\020\014"
  ;
static ::_pbi::once_flag descriptor_table_update_5fmetadata_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_update_5fmetadata_2eproto = {
    false, false, 3057, descriptor_table_protodef_update_5fmetadata_2eproto,
    "update_metadata.proto",
    &descriptor_table_update_5fmetadata_2eproto_once, nullptr, 0, 13,
    schemas, file_default_instances, TableStruct_update_5fmetadata_2eproto::offsets,
    file_level_metadata_update_5fmetadata_2eproto, file_level_enum_descriptors_update_5fmetadata_2eproto,
    file_level_service_descriptors_update_5fmetadata_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_update_5fmetadata_2eproto_getter() {
  return &descriptor_table_update_5fmetadata_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_update_5fmetadata_2eproto(&descriptor_table_update_5fmetadata_2eproto);
namespace chromeos_update_engine {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InstallOperation_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_update_5fmetadata_2eproto);
  return file_level_enum_descriptors_update_5fmetadata_2eproto[0];
}
bool InstallOperation_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr InstallOperation_Type InstallOperation::REPLACE;
constexpr InstallOperation_Type InstallOperation::REPLACE_BZ;
constexpr InstallOperation_Type InstallOperation::MOVE;
constexpr InstallOperation_Type InstallOperation::BSDIFF;
constexpr InstallOperation_Type InstallOperation::SOURCE_COPY;
constexpr InstallOperation_Type InstallOperation::SOURCE_BSDIFF;
constexpr InstallOperation_Type InstallOperation::REPLACE_XZ;
constexpr InstallOperation_Type InstallOperation::ZERO;
constexpr InstallOperation_Type InstallOperation::DISCARD;
constexpr InstallOperation_Type InstallOperation::BROTLI_BSDIFF;
constexpr InstallOperation_Type InstallOperation::PUFFDIFF;
constexpr InstallOperation_Type InstallOperation::ZUCCHINI;
constexpr InstallOperation_Type InstallOperation::LZ4DIFF_BSDIFF;
constexpr InstallOperation_Type InstallOperation::LZ4DIFF_PUFFDIFF;
constexpr InstallOperation_Type InstallOperation::REPLACE_ZSTD;
constexpr InstallOperation_Type InstallOperation::Type_MIN;
constexpr InstallOperation_Type InstallOperation::Type_MAX;
constexpr int InstallOperation::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CowMergeOperation_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_update_5fmetadata_2eproto);
  return file_level_enum_descriptors_update_5fmetadata_2eproto[1];
}
bool CowMergeOperation_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CowMergeOperation_Type CowMergeOperation::COW_COPY;
constexpr CowMergeOperation_Type CowMergeOperation::COW_XOR;
constexpr CowMergeOperation_Type CowMergeOperation::COW_REPLACE;
constexpr CowMergeOperation_Type CowMergeOperation::Type_MIN;
constexpr CowMergeOperation_Type CowMergeOperation::Type_MAX;
constexpr int CowMergeOperation::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class Extent::_Internal {
 public:
  using HasBits = decltype(std::declval<Extent>()._impl_._has_bits_);
  static void set_has_start_block(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Extent::Extent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.Extent)
}
Extent::Extent(const Extent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Extent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_block_){}
    , decltype(_impl_.num_blocks_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.start_block_, &from._impl_.start_block_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_blocks_) -
    reinterpret_cast<char*>(&_impl_.start_block_)) + sizeof(_impl_.num_blocks_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.Extent)
}

inline void Extent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_block_){::uint64_t{0u}}
    , decltype(_impl_.num_blocks_){::uint64_t{0u}}
  };
}

Extent::~Extent() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.Extent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Extent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Extent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Extent::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.Extent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.start_block_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.num_blocks_) -
        reinterpret_cast<char*>(&_impl_.start_block_)) + sizeof(_impl_.num_blocks_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Extent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 start_block = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_start_block(&has_bits);
          _impl_.start_block_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 num_blocks = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_num_blocks(&has_bits);
          _impl_.num_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Extent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.Extent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 start_block = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_start_block(), target);
  }

  // optional uint64 num_blocks = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_num_blocks(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.Extent)
  return target;
}

size_t Extent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.Extent)
  size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 start_block = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_start_block());
    }

    // optional uint64 num_blocks = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_num_blocks());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Extent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Extent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Extent::GetClassData() const { return &_class_data_; }


void Extent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Extent*>(&to_msg);
  auto& from = static_cast<const Extent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.Extent)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.start_block_ = from._impl_.start_block_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.num_blocks_ = from._impl_.num_blocks_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Extent::CopyFrom(const Extent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.Extent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Extent::IsInitialized() const {
  return true;
}

void Extent::InternalSwap(Extent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Extent, _impl_.num_blocks_)
      + sizeof(Extent::_impl_.num_blocks_)  // NOLINT
      - PROTOBUF_FIELD_OFFSET(Extent, _impl_.start_block_)>(
          reinterpret_cast<char*>(&_impl_.start_block_),
          reinterpret_cast<char*>(&other->_impl_.start_block_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Extent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[0]);
}

// ===================================================================

class Signatures_Signature::_Internal {
 public:
  using HasBits = decltype(std::declval<Signatures_Signature>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_unpadded_signature_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Signatures_Signature::Signatures_Signature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.Signatures.Signature)
}
Signatures_Signature::Signatures_Signature(const Signatures_Signature& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Signatures_Signature* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.unpadded_signature_size_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.version_, &from._impl_.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.unpadded_signature_size_) -
    reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.unpadded_signature_size_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.Signatures.Signature)
}

inline void Signatures_Signature::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.version_){0u}
    , decltype(_impl_.unpadded_signature_size_){0u}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Signatures_Signature::~Signatures_Signature() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.Signatures.Signature)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Signatures_Signature::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void Signatures_Signature::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Signatures_Signature::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.Signatures.Signature)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.unpadded_signature_size_) -
        reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.unpadded_signature_size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Signatures_Signature::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 version = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bytes data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional fixed32 unpadded_signature_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _Internal::set_has_unpadded_signature_size(&has_bits);
          _impl_.unpadded_signature_size_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::uint32_t>(ptr);
          ptr += sizeof(::uint32_t);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Signatures_Signature::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.Signatures.Signature)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 version = 1 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_version(), target);
  }

  // optional bytes data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_data(), target);
  }

  // optional fixed32 unpadded_signature_size = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(3, this->_internal_unpadded_signature_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.Signatures.Signature)
  return target;
}

size_t Signatures_Signature::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.Signatures.Signature)
  size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional uint32 version = 1 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
    }

    // optional fixed32 unpadded_signature_size = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Signatures_Signature::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Signatures_Signature::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Signatures_Signature::GetClassData() const { return &_class_data_; }


void Signatures_Signature::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Signatures_Signature*>(&to_msg);
  auto& from = static_cast<const Signatures_Signature&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.Signatures.Signature)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.unpadded_signature_size_ = from._impl_.unpadded_signature_size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Signatures_Signature::CopyFrom(const Signatures_Signature& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.Signatures.Signature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Signatures_Signature::IsInitialized() const {
  return true;
}

void Signatures_Signature::InternalSwap(Signatures_Signature* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Signatures_Signature, _impl_.unpadded_signature_size_)
      + sizeof(Signatures_Signature::_impl_.unpadded_signature_size_)  // NOLINT
      - PROTOBUF_FIELD_OFFSET(Signatures_Signature, _impl_.version_)>(
          reinterpret_cast<char*>(&_impl_.version_),
          reinterpret_cast<char*>(&other->_impl_.version_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Signatures_Signature::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[1]);
}

// ===================================================================

class Signatures::_Internal {
 public:
};

Signatures::Signatures(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.Signatures)
}
Signatures::Signatures(const Signatures& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Signatures* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.signatures_){from._impl_.signatures_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.Signatures)
}

inline void Signatures::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.signatures_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Signatures::~Signatures() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.Signatures)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Signatures::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.signatures_.~RepeatedPtrField();
}

void Signatures::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Signatures::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.Signatures)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.signatures_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Signatures::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_signatures(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Signatures::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.Signatures)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_signatures_size()); i < n; i++) {
    const auto& repfield = this->_internal_signatures(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.Signatures)
  return target;
}

size_t Signatures::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.Signatures)
  size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
  total_size += 1UL * this->_internal_signatures_size();
  for (const auto& msg : this->_impl_.signatures_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Signatures::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Signatures::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Signatures::GetClassData() const { return &_class_data_; }


void Signatures::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Signatures*>(&to_msg);
  auto& from = static_cast<const Signatures&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.Signatures)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.signatures_.MergeFrom(from._impl_.signatures_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Signatures::CopyFrom(const Signatures& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.Signatures)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Signatures::IsInitialized() const {
  return true;
}

void Signatures::InternalSwap(Signatures* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.signatures_.InternalSwap(&other->_impl_.signatures_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Signatures::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[2]);
}

// ===================================================================

class PartitionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<PartitionInfo>()._impl_._has_bits_);
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PartitionInfo::PartitionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.PartitionInfo)
}
PartitionInfo::PartitionInfo(const PartitionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PartitionInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hash_){}
    , decltype(_impl_.size_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hash()) {
    _this->_impl_.hash_.Set(from._internal_hash(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.size_ = from._impl_.size_;
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.PartitionInfo)
}

inline void PartitionInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hash_){}
    , decltype(_impl_.size_){::uint64_t{0u}}
  };
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PartitionInfo::~PartitionInfo() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.PartitionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PartitionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hash_.Destroy();
}

void PartitionInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PartitionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.PartitionInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.hash_.ClearNonDefaultToEmpty();
  }
  _impl_.size_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PartitionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bytes hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PartitionInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.PartitionInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 size = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_size(), target);
  }

  // optional bytes hash = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.PartitionInfo)
  return target;
}

size_t PartitionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.PartitionInfo)
  size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes hash = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_hash());
    }

    // optional uint64 size = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_size());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PartitionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PartitionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PartitionInfo::GetClassData() const { return &_class_data_; }


void PartitionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PartitionInfo*>(&to_msg);
  auto& from = static_cast<const PartitionInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.PartitionInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_hash(from._internal_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PartitionInfo::CopyFrom(const PartitionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.PartitionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PartitionInfo::IsInitialized() const {
  return true;
}

void PartitionInfo::InternalSwap(PartitionInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hash_, lhs_arena,
      &other->_impl_.hash_, rhs_arena
  );
  swap(_impl_.size_, other->_impl_.size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PartitionInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[3]);
}

// ===================================================================

class InstallOperation::_Internal {
 public:
  using HasBits = decltype(std::declval<InstallOperation>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_data_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_data_length(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_src_length(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dst_length(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_data_sha256_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_src_sha256_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000040) ^ 0x00000040) != 0;
  }
};

InstallOperation::InstallOperation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.InstallOperation)
}
InstallOperation::InstallOperation(const InstallOperation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InstallOperation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.src_extents_){from._impl_.src_extents_}
    , decltype(_impl_.dst_extents_){from._impl_.dst_extents_}
    , decltype(_impl_.data_sha256_hash_){}
    , decltype(_impl_.src_sha256_hash_){}
    , decltype(_impl_.data_offset_){}
    , decltype(_impl_.data_length_){}
    , decltype(_impl_.src_length_){}
    , decltype(_impl_.dst_length_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_sha256_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_sha256_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data_sha256_hash()) {
    _this->_impl_.data_sha256_hash_.Set(from._internal_data_sha256_hash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.src_sha256_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.src_sha256_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_src_sha256_hash()) {
    _this->_impl_.src_sha256_hash_.Set(from._internal_src_sha256_hash(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.data_offset_, &from._impl_.data_offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.data_offset_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.InstallOperation)
}

inline void InstallOperation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.src_extents_){arena}
    , decltype(_impl_.dst_extents_){arena}
    , decltype(_impl_.data_sha256_hash_){}
    , decltype(_impl_.src_sha256_hash_){}
    , decltype(_impl_.data_offset_){::uint64_t{0u}}
    , decltype(_impl_.data_length_){::uint64_t{0u}}
    , decltype(_impl_.src_length_){::uint64_t{0u}}
    , decltype(_impl_.dst_length_){::uint64_t{0u}}
    , decltype(_impl_.type_){0}
  };
  _impl_.data_sha256_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_sha256_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.src_sha256_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.src_sha256_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InstallOperation::~InstallOperation() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.InstallOperation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InstallOperation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.src_extents_.~RepeatedPtrField();
  _impl_.dst_extents_.~RepeatedPtrField();
  _impl_.data_sha256_hash_.Destroy();
  _impl_.src_sha256_hash_.Destroy();
}

void InstallOperation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InstallOperation::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.InstallOperation)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.src_extents_.Clear();
  _impl_.dst_extents_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.data_sha256_hash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.src_sha256_hash_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&_impl_.data_offset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.data_offset_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InstallOperation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .chromeos_update_engine.InstallOperation.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::chromeos_update_engine::InstallOperation_Type_IsValid(val))) {
            _internal_set_type(static_cast<::chromeos_update_engine::InstallOperation_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 data_offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_data_offset(&has_bits);
          _impl_.data_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 data_length = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_data_length(&has_bits);
          _impl_.data_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .chromeos_update_engine.Extent src_extents = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_src_extents(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 src_length = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_src_length(&has_bits);
          _impl_.src_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .chromeos_update_engine.Extent dst_extents = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_dst_extents(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 dst_length = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_dst_length(&has_bits);
          _impl_.dst_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bytes data_sha256_hash = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_data_sha256_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bytes src_sha256_hash = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_src_sha256_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* InstallOperation::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.InstallOperation)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .chromeos_update_engine.InstallOperation.Type type = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional uint64 data_offset = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_data_offset(), target);
  }

  // optional uint64 data_length = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_data_length(), target);
  }

  // repeated .chromeos_update_engine.Extent src_extents = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_src_extents_size()); i < n; i++) {
    const auto& repfield = this->_internal_src_extents(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint64 src_length = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_src_length(), target);
  }

  // repeated .chromeos_update_engine.Extent dst_extents = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_dst_extents_size()); i < n; i++) {
    const auto& repfield = this->_internal_dst_extents(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint64 dst_length = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_dst_length(), target);
  }

  // optional bytes data_sha256_hash = 8;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_data_sha256_hash(), target);
  }

  // optional bytes src_sha256_hash = 9;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_src_sha256_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.InstallOperation)
  return target;
}

size_t InstallOperation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.InstallOperation)
  size_t total_size = 0;

  // required .chromeos_update_engine.InstallOperation.Type type = 1;
  if (_internal_has_type()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.Extent src_extents = 4;
  total_size += 1UL * this->_internal_src_extents_size();
  for (const auto& msg : this->_impl_.src_extents_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .chromeos_update_engine.Extent dst_extents = 6;
  total_size += 1UL * this->_internal_dst_extents_size();
  for (const auto& msg : this->_impl_.dst_extents_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes data_sha256_hash = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data_sha256_hash());
    }

    // optional bytes src_sha256_hash = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_src_sha256_hash());
    }

    // optional uint64 data_offset = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_data_offset());
    }

    // optional uint64 data_length = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_data_length());
    }

    // optional uint64 src_length = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_src_length());
    }

    // optional uint64 dst_length = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dst_length());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InstallOperation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InstallOperation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InstallOperation::GetClassData() const { return &_class_data_; }


void InstallOperation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InstallOperation*>(&to_msg);
  auto& from = static_cast<const InstallOperation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.InstallOperation)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.src_extents_.MergeFrom(from._impl_.src_extents_);
  _this->_impl_.dst_extents_.MergeFrom(from._impl_.dst_extents_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_data_sha256_hash(from._internal_data_sha256_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_src_sha256_hash(from._internal_src_sha256_hash());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.data_offset_ = from._impl_.data_offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.data_length_ = from._impl_.data_length_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.src_length_ = from._impl_.src_length_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.dst_length_ = from._impl_.dst_length_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InstallOperation::CopyFrom(const InstallOperation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.InstallOperation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InstallOperation::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void InstallOperation::InternalSwap(InstallOperation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.src_extents_.InternalSwap(&other->_impl_.src_extents_);
  _impl_.dst_extents_.InternalSwap(&other->_impl_.dst_extents_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_sha256_hash_, lhs_arena,
      &other->_impl_.data_sha256_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.src_sha256_hash_, lhs_arena,
      &other->_impl_.src_sha256_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InstallOperation, _impl_.type_)
      + sizeof(InstallOperation::_impl_.type_)  // NOLINT
      - PROTOBUF_FIELD_OFFSET(InstallOperation, _impl_.data_offset_)>(
          reinterpret_cast<char*>(&_impl_.data_offset_),
          reinterpret_cast<char*>(&other->_impl_.data_offset_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InstallOperation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[4]);
}

// ===================================================================

class CowMergeOperation::_Internal {
 public:
  using HasBits = decltype(std::declval<CowMergeOperation>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::chromeos_update_engine::Extent& src_extent(const CowMergeOperation* msg);
  static void set_has_src_extent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::chromeos_update_engine::Extent& dst_extent(const CowMergeOperation* msg);
  static void set_has_dst_extent(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_src_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::chromeos_update_engine::Extent&
CowMergeOperation::_Internal::src_extent(const CowMergeOperation* msg) {
  return *msg->_impl_.src_extent_;
}
const ::chromeos_update_engine::Extent&
CowMergeOperation::_Internal::dst_extent(const CowMergeOperation* msg) {
  return *msg->_impl_.dst_extent_;
}
CowMergeOperation::CowMergeOperation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.CowMergeOperation)
}
CowMergeOperation::CowMergeOperation(const CowMergeOperation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CowMergeOperation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.src_extent_){nullptr}
    , decltype(_impl_.dst_extent_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.src_offset_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_src_extent()) {
    _this->_impl_.src_extent_ = new ::chromeos_update_engine::Extent(*from._impl_.src_extent_);
  }
  if (from._internal_has_dst_extent()) {
    _this->_impl_.dst_extent_ = new ::chromeos_update_engine::Extent(*from._impl_.dst_extent_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.src_offset_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.src_offset_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.CowMergeOperation)
}

inline void CowMergeOperation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.src_extent_){nullptr}
    , decltype(_impl_.dst_extent_){nullptr}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.src_offset_){0u}
  };
}

CowMergeOperation::~CowMergeOperation() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.CowMergeOperation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CowMergeOperation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.src_extent_;
  if (this != internal_default_instance()) delete _impl_.dst_extent_;
}

void CowMergeOperation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CowMergeOperation::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.CowMergeOperation)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.src_extent_ != nullptr);
      _impl_.src_extent_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.dst_extent_ != nullptr);
      _impl_.dst_extent_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.src_offset_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.src_offset_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CowMergeOperation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::chromeos_update_engine::CowMergeOperation_Type_IsValid(val))) {
            _internal_set_type(static_cast<::chromeos_update_engine::CowMergeOperation_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .chromeos_update_engine.Extent src_extent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_src_extent(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .chromeos_update_engine.Extent dst_extent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_dst_extent(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 src_offset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_src_offset(&has_bits);
          _impl_.src_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CowMergeOperation::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.CowMergeOperation)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional .chromeos_update_engine.Extent src_extent = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::src_extent(this),
        _Internal::src_extent(this).GetCachedSize(), target, stream);
  }

  // optional .chromeos_update_engine.Extent dst_extent = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::dst_extent(this),
        _Internal::dst_extent(this).GetCachedSize(), target, stream);
  }

  // optional uint32 src_offset = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_src_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.CowMergeOperation)
  return target;
}

size_t CowMergeOperation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.CowMergeOperation)
  size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .chromeos_update_engine.Extent src_extent = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.src_extent_);
    }

    // optional .chromeos_update_engine.Extent dst_extent = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dst_extent_);
    }

    // optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional uint32 src_offset = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_src_offset());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CowMergeOperation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CowMergeOperation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CowMergeOperation::GetClassData() const { return &_class_data_; }


void CowMergeOperation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CowMergeOperation*>(&to_msg);
  auto& from = static_cast<const CowMergeOperation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.CowMergeOperation)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_src_extent()->::chromeos_update_engine::Extent::MergeFrom(
          from._internal_src_extent());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_dst_extent()->::chromeos_update_engine::Extent::MergeFrom(
          from._internal_dst_extent());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.src_offset_ = from._impl_.src_offset_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CowMergeOperation::CopyFrom(const CowMergeOperation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.CowMergeOperation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CowMergeOperation::IsInitialized() const {
  return true;
}

void CowMergeOperation::InternalSwap(CowMergeOperation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CowMergeOperation, _impl_.src_offset_)
      + sizeof(CowMergeOperation::_impl_.src_offset_)  // NOLINT
      - PROTOBUF_FIELD_OFFSET(CowMergeOperation, _impl_.src_extent_)>(
          reinterpret_cast<char*>(&_impl_.src_extent_),
          reinterpret_cast<char*>(&other->_impl_.src_extent_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CowMergeOperation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[5]);
}

// ===================================================================

class PartitionUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<PartitionUpdate>()._impl_._has_bits_);
  static void set_has_partition_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_run_postinstall(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_postinstall_path(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_filesystem_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::chromeos_update_engine::PartitionInfo& old_partition_info(const PartitionUpdate* msg);
  static void set_has_old_partition_info(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::chromeos_update_engine::PartitionInfo& new_partition_info(const PartitionUpdate* msg);
  static void set_has_new_partition_info(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_postinstall_optional(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::chromeos_update_engine::Extent& hash_tree_data_extent(const PartitionUpdate* msg);
  static void set_has_hash_tree_data_extent(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::chromeos_update_engine::Extent& hash_tree_extent(const PartitionUpdate* msg);
  static void set_has_hash_tree_extent(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_hash_tree_algorithm(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_hash_tree_salt(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::chromeos_update_engine::Extent& fec_data_extent(const PartitionUpdate* msg);
  static void set_has_fec_data_extent(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::chromeos_update_engine::Extent& fec_extent(const PartitionUpdate* msg);
  static void set_has_fec_extent(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_fec_roots(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_estimate_cow_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_estimate_op_count_max(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::chromeos_update_engine::PartitionInfo&
PartitionUpdate::_Internal::old_partition_info(const PartitionUpdate* msg) {
  return *msg->_impl_.old_partition_info_;
}
const ::chromeos_update_engine::PartitionInfo&
PartitionUpdate::_Internal::new_partition_info(const PartitionUpdate* msg) {
  return *msg->_impl_.new_partition_info_;
}
const ::chromeos_update_engine::Extent&
PartitionUpdate::_Internal::hash_tree_data_extent(const PartitionUpdate* msg) {
  return *msg->_impl_.hash_tree_data_extent_;
}
const ::chromeos_update_engine::Extent&
PartitionUpdate::_Internal::hash_tree_extent(const PartitionUpdate* msg) {
  return *msg->_impl_.hash_tree_extent_;
}
const ::chromeos_update_engine::Extent&
PartitionUpdate::_Internal::fec_data_extent(const PartitionUpdate* msg) {
  return *msg->_impl_.fec_data_extent_;
}
const ::chromeos_update_engine::Extent&
PartitionUpdate::_Internal::fec_extent(const PartitionUpdate* msg) {
  return *msg->_impl_.fec_extent_;
}
PartitionUpdate::PartitionUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.PartitionUpdate)
}
PartitionUpdate::PartitionUpdate(const PartitionUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PartitionUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.new_partition_signature_){from._impl_.new_partition_signature_}
    , decltype(_impl_.operations_){from._impl_.operations_}
    , decltype(_impl_.merge_operations_){from._impl_.merge_operations_}
    , decltype(_impl_.partition_name_){}
    , decltype(_impl_.postinstall_path_){}
    , decltype(_impl_.filesystem_type_){}
    , decltype(_impl_.hash_tree_algorithm_){}
    , decltype(_impl_.hash_tree_salt_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.old_partition_info_){nullptr}
    , decltype(_impl_.new_partition_info_){nullptr}
    , decltype(_impl_.hash_tree_data_extent_){nullptr}
    , decltype(_impl_.hash_tree_extent_){nullptr}
    , decltype(_impl_.fec_data_extent_){nullptr}
    , decltype(_impl_.fec_extent_){nullptr}
    , decltype(_impl_.estimate_cow_size_){}
    , decltype(_impl_.estimate_op_count_max_){}
    , decltype(_impl_.run_postinstall_){}
    , decltype(_impl_.postinstall_optional_){}
    , decltype(_impl_.fec_roots_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.partition_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.partition_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_partition_name()) {
    _this->_impl_.partition_name_.Set(from._internal_partition_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.postinstall_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.postinstall_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_postinstall_path()) {
    _this->_impl_.postinstall_path_.Set(from._internal_postinstall_path(), 
      _this->GetArenaForAllocation());
  }
  _impl_.filesystem_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filesystem_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filesystem_type()) {
    _this->_impl_.filesystem_type_.Set(from._internal_filesystem_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.hash_tree_algorithm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_tree_algorithm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hash_tree_algorithm()) {
    _this->_impl_.hash_tree_algorithm_.Set(from._internal_hash_tree_algorithm(), 
      _this->GetArenaForAllocation());
  }
  _impl_.hash_tree_salt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_tree_salt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hash_tree_salt()) {
    _this->_impl_.hash_tree_salt_.Set(from._internal_hash_tree_salt(), 
      _this->GetArenaForAllocation());
  }
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version()) {
    _this->_impl_.version_.Set(from._internal_version(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_old_partition_info()) {
    _this->_impl_.old_partition_info_ = new ::chromeos_update_engine::PartitionInfo(*from._impl_.old_partition_info_);
  }
  if (from._internal_has_new_partition_info()) {
    _this->_impl_.new_partition_info_ = new ::chromeos_update_engine::PartitionInfo(*from._impl_.new_partition_info_);
  }
  if (from._internal_has_hash_tree_data_extent()) {
    _this->_impl_.hash_tree_data_extent_ = new ::chromeos_update_engine::Extent(*from._impl_.hash_tree_data_extent_);
  }
  if (from._internal_has_hash_tree_extent()) {
    _this->_impl_.hash_tree_extent_ = new ::chromeos_update_engine::Extent(*from._impl_.hash_tree_extent_);
  }
  if (from._internal_has_fec_data_extent()) {
    _this->_impl_.fec_data_extent_ = new ::chromeos_update_engine::Extent(*from._impl_.fec_data_extent_);
  }
  if (from._internal_has_fec_extent()) {
    _this->_impl_.fec_extent_ = new ::chromeos_update_engine::Extent(*from._impl_.fec_extent_);
  }
  ::memcpy(&_impl_.estimate_cow_size_, &from._impl_.estimate_cow_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.fec_roots_) -
    reinterpret_cast<char*>(&_impl_.estimate_cow_size_)) + sizeof(_impl_.fec_roots_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.PartitionUpdate)
}

inline void PartitionUpdate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.new_partition_signature_){arena}
    , decltype(_impl_.operations_){arena}
    , decltype(_impl_.merge_operations_){arena}
    , decltype(_impl_.partition_name_){}
    , decltype(_impl_.postinstall_path_){}
    , decltype(_impl_.filesystem_type_){}
    , decltype(_impl_.hash_tree_algorithm_){}
    , decltype(_impl_.hash_tree_salt_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.old_partition_info_){nullptr}
    , decltype(_impl_.new_partition_info_){nullptr}
    , decltype(_impl_.hash_tree_data_extent_){nullptr}
    , decltype(_impl_.hash_tree_extent_){nullptr}
    , decltype(_impl_.fec_data_extent_){nullptr}
    , decltype(_impl_.fec_extent_){nullptr}
    , decltype(_impl_.estimate_cow_size_){::uint64_t{0u}}
    , decltype(_impl_.estimate_op_count_max_){::uint64_t{0u}}
    , decltype(_impl_.run_postinstall_){false}
    , decltype(_impl_.postinstall_optional_){false}
    , decltype(_impl_.fec_roots_){2u}
  };
  _impl_.partition_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.partition_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.postinstall_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.postinstall_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.filesystem_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filesystem_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hash_tree_algorithm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_tree_algorithm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hash_tree_salt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_tree_salt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PartitionUpdate::~PartitionUpdate() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.PartitionUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PartitionUpdate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.new_partition_signature_.~RepeatedPtrField();
  _impl_.operations_.~RepeatedPtrField();
  _impl_.merge_operations_.~RepeatedPtrField();
  _impl_.partition_name_.Destroy();
  _impl_.postinstall_path_.Destroy();
  _impl_.filesystem_type_.Destroy();
  _impl_.hash_tree_algorithm_.Destroy();
  _impl_.hash_tree_salt_.Destroy();
  _impl_.version_.Destroy();
  if (this != internal_default_instance()) delete _impl_.old_partition_info_;
  if (this != internal_default_instance()) delete _impl_.new_partition_info_;
  if (this != internal_default_instance()) delete _impl_.hash_tree_data_extent_;
  if (this != internal_default_instance()) delete _impl_.hash_tree_extent_;
  if (this != internal_default_instance()) delete _impl_.fec_data_extent_;
  if (this != internal_default_instance()) delete _impl_.fec_extent_;
}

void PartitionUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PartitionUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.PartitionUpdate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.new_partition_signature_.Clear();
  _impl_.operations_.Clear();
  _impl_.merge_operations_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.partition_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.postinstall_path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.filesystem_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.hash_tree_algorithm_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.hash_tree_salt_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.old_partition_info_ != nullptr);
      _impl_.old_partition_info_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.new_partition_info_ != nullptr);
      _impl_.new_partition_info_->Clear();
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.hash_tree_data_extent_ != nullptr);
      _impl_.hash_tree_data_extent_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.hash_tree_extent_ != nullptr);
      _impl_.hash_tree_extent_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.fec_data_extent_ != nullptr);
      _impl_.fec_data_extent_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.fec_extent_ != nullptr);
      _impl_.fec_extent_->Clear();
    }
  }
  if (cached_has_bits & 0x0000f000u) {
    ::memset(&_impl_.estimate_cow_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.postinstall_optional_) -
        reinterpret_cast<char*>(&_impl_.estimate_cow_size_)) + sizeof(_impl_.postinstall_optional_));
  }
  _impl_.fec_roots_ = 2u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PartitionUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string partition_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_partition_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "chromeos_update_engine.PartitionUpdate.partition_name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool run_postinstall = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_run_postinstall(&has_bits);
          _impl_.run_postinstall_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string postinstall_path = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_postinstall_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "chromeos_update_engine.PartitionUpdate.postinstall_path");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string filesystem_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_filesystem_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "chromeos_update_engine.PartitionUpdate.filesystem_type");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_new_partition_signature(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_partition_info(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_partition_info(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .chromeos_update_engine.InstallOperation operations = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_operations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool postinstall_optional = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _Internal::set_has_postinstall_optional(&has_bits);
          _impl_.postinstall_optional_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_hash_tree_data_extent(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .chromeos_update_engine.Extent hash_tree_extent = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_hash_tree_extent(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string hash_tree_algorithm = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_hash_tree_algorithm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "chromeos_update_engine.PartitionUpdate.hash_tree_algorithm");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bytes hash_tree_salt = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_hash_tree_salt();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .chromeos_update_engine.Extent fec_data_extent = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_fec_data_extent(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .chromeos_update_engine.Extent fec_extent = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_fec_extent(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 fec_roots = 16 [default = 2];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _Internal::set_has_fec_roots(&has_bits);
          _impl_.fec_roots_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string version = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "chromeos_update_engine.PartitionUpdate.version");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_merge_operations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<146>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 estimate_cow_size = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 152)) {
          _Internal::set_has_estimate_cow_size(&has_bits);
          _impl_.estimate_cow_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 estimate_op_count_max = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 160)) {
          _Internal::set_has_estimate_op_count_max(&has_bits);
          _impl_.estimate_op_count_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PartitionUpdate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.PartitionUpdate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string partition_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_partition_name().data(), static_cast<int>(this->_internal_partition_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "chromeos_update_engine.PartitionUpdate.partition_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_partition_name(), target);
  }

  // optional bool run_postinstall = 2;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_run_postinstall(), target);
  }

  // optional string postinstall_path = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_postinstall_path().data(), static_cast<int>(this->_internal_postinstall_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "chromeos_update_engine.PartitionUpdate.postinstall_path");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_postinstall_path(), target);
  }

  // optional string filesystem_type = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_filesystem_type().data(), static_cast<int>(this->_internal_filesystem_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "chromeos_update_engine.PartitionUpdate.filesystem_type");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_filesystem_type(), target);
  }

  // repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_new_partition_signature_size()); i < n; i++) {
    const auto& repfield = this->_internal_new_partition_signature(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::old_partition_info(this),
        _Internal::old_partition_info(this).GetCachedSize(), target, stream);
  }

  // optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::new_partition_info(this),
        _Internal::new_partition_info(this).GetCachedSize(), target, stream);
  }

  // repeated .chromeos_update_engine.InstallOperation operations = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_operations_size()); i < n; i++) {
    const auto& repfield = this->_internal_operations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool postinstall_optional = 9;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_postinstall_optional(), target);
  }

  // optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::hash_tree_data_extent(this),
        _Internal::hash_tree_data_extent(this).GetCachedSize(), target, stream);
  }

  // optional .chromeos_update_engine.Extent hash_tree_extent = 11;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::hash_tree_extent(this),
        _Internal::hash_tree_extent(this).GetCachedSize(), target, stream);
  }

  // optional string hash_tree_algorithm = 12;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hash_tree_algorithm().data(), static_cast<int>(this->_internal_hash_tree_algorithm().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "chromeos_update_engine.PartitionUpdate.hash_tree_algorithm");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_hash_tree_algorithm(), target);
  }

  // optional bytes hash_tree_salt = 13;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        13, this->_internal_hash_tree_salt(), target);
  }

  // optional .chromeos_update_engine.Extent fec_data_extent = 14;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::fec_data_extent(this),
        _Internal::fec_data_extent(this).GetCachedSize(), target, stream);
  }

  // optional .chromeos_update_engine.Extent fec_extent = 15;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::fec_extent(this),
        _Internal::fec_extent(this).GetCachedSize(), target, stream);
  }

  // optional uint32 fec_roots = 16 [default = 2];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_fec_roots(), target);
  }

  // optional string version = 17;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "chromeos_update_engine.PartitionUpdate.version");
    target = stream->WriteStringMaybeAliased(
        17, this->_internal_version(), target);
  }

  // repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_merge_operations_size()); i < n; i++) {
    const auto& repfield = this->_internal_merge_operations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(18, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint64 estimate_cow_size = 19;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(19, this->_internal_estimate_cow_size(), target);
  }

  // optional uint64 estimate_op_count_max = 20;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(20, this->_internal_estimate_op_count_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.PartitionUpdate)
  return target;
}

size_t PartitionUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.PartitionUpdate)
  size_t total_size = 0;

  // required string partition_name = 1;
  if (_internal_has_partition_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_partition_name());
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
  total_size += 1UL * this->_internal_new_partition_signature_size();
  for (const auto& msg : this->_impl_.new_partition_signature_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .chromeos_update_engine.InstallOperation operations = 8;
  total_size += 1UL * this->_internal_operations_size();
  for (const auto& msg : this->_impl_.operations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
  total_size += 2UL * this->_internal_merge_operations_size();
  for (const auto& msg : this->_impl_.merge_operations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional string postinstall_path = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_postinstall_path());
    }

    // optional string filesystem_type = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_filesystem_type());
    }

    // optional string hash_tree_algorithm = 12;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hash_tree_algorithm());
    }

    // optional bytes hash_tree_salt = 13;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_hash_tree_salt());
    }

    // optional string version = 17;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version());
    }

    // optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.old_partition_info_);
    }

    // optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.new_partition_info_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.hash_tree_data_extent_);
    }

    // optional .chromeos_update_engine.Extent hash_tree_extent = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.hash_tree_extent_);
    }

    // optional .chromeos_update_engine.Extent fec_data_extent = 14;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.fec_data_extent_);
    }

    // optional .chromeos_update_engine.Extent fec_extent = 15;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.fec_extent_);
    }

    // optional uint64 estimate_cow_size = 19;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_estimate_cow_size());
    }

    // optional uint64 estimate_op_count_max = 20;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_estimate_op_count_max());
    }

    // optional bool run_postinstall = 2;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool postinstall_optional = 9;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 1;
    }

  }
  // optional uint32 fec_roots = 16 [default = 2];
  if (cached_has_bits & 0x00010000u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_fec_roots());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PartitionUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PartitionUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PartitionUpdate::GetClassData() const { return &_class_data_; }


void PartitionUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PartitionUpdate*>(&to_msg);
  auto& from = static_cast<const PartitionUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.PartitionUpdate)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.new_partition_signature_.MergeFrom(from._impl_.new_partition_signature_);
  _this->_impl_.operations_.MergeFrom(from._impl_.operations_);
  _this->_impl_.merge_operations_.MergeFrom(from._impl_.merge_operations_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_partition_name(from._internal_partition_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_postinstall_path(from._internal_postinstall_path());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_filesystem_type(from._internal_filesystem_type());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_hash_tree_algorithm(from._internal_hash_tree_algorithm());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_hash_tree_salt(from._internal_hash_tree_salt());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_old_partition_info()->::chromeos_update_engine::PartitionInfo::MergeFrom(
          from._internal_old_partition_info());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_new_partition_info()->::chromeos_update_engine::PartitionInfo::MergeFrom(
          from._internal_new_partition_info());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_hash_tree_data_extent()->::chromeos_update_engine::Extent::MergeFrom(
          from._internal_hash_tree_data_extent());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_hash_tree_extent()->::chromeos_update_engine::Extent::MergeFrom(
          from._internal_hash_tree_extent());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_fec_data_extent()->::chromeos_update_engine::Extent::MergeFrom(
          from._internal_fec_data_extent());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_fec_extent()->::chromeos_update_engine::Extent::MergeFrom(
          from._internal_fec_extent());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.estimate_cow_size_ = from._impl_.estimate_cow_size_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.estimate_op_count_max_ = from._impl_.estimate_op_count_max_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.run_postinstall_ = from._impl_.run_postinstall_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.postinstall_optional_ = from._impl_.postinstall_optional_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00010000u) {
    _this->_internal_set_fec_roots(from._internal_fec_roots());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PartitionUpdate::CopyFrom(const PartitionUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.PartitionUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PartitionUpdate::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.operations_))
    return false;
  return true;
}

void PartitionUpdate::InternalSwap(PartitionUpdate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.new_partition_signature_.InternalSwap(&other->_impl_.new_partition_signature_);
  _impl_.operations_.InternalSwap(&other->_impl_.operations_);
  _impl_.merge_operations_.InternalSwap(&other->_impl_.merge_operations_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.partition_name_, lhs_arena,
      &other->_impl_.partition_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.postinstall_path_, lhs_arena,
      &other->_impl_.postinstall_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filesystem_type_, lhs_arena,
      &other->_impl_.filesystem_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hash_tree_algorithm_, lhs_arena,
      &other->_impl_.hash_tree_algorithm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hash_tree_salt_, lhs_arena,
      &other->_impl_.hash_tree_salt_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PartitionUpdate, _impl_.postinstall_optional_)
      + sizeof(PartitionUpdate::_impl_.postinstall_optional_)  // NOLINT
      - PROTOBUF_FIELD_OFFSET(PartitionUpdate, _impl_.old_partition_info_)>(
          reinterpret_cast<char*>(&_impl_.old_partition_info_),
          reinterpret_cast<char*>(&other->_impl_.old_partition_info_));
  swap(_impl_.fec_roots_, other->_impl_.fec_roots_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PartitionUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[6]);
}

// ===================================================================

class DynamicPartitionGroup::_Internal {
 public:
  using HasBits = decltype(std::declval<DynamicPartitionGroup>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

DynamicPartitionGroup::DynamicPartitionGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.DynamicPartitionGroup)
}
DynamicPartitionGroup::DynamicPartitionGroup(const DynamicPartitionGroup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DynamicPartitionGroup* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.partition_names_){from._impl_.partition_names_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.size_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.size_ = from._impl_.size_;
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.DynamicPartitionGroup)
}

inline void DynamicPartitionGroup::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.partition_names_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.size_){::uint64_t{0u}}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DynamicPartitionGroup::~DynamicPartitionGroup() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.DynamicPartitionGroup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DynamicPartitionGroup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.partition_names_.~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void DynamicPartitionGroup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DynamicPartitionGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.DynamicPartitionGroup)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.partition_names_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_.size_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DynamicPartitionGroup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "chromeos_update_engine.DynamicPartitionGroup.name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string partition_names = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_partition_names();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "chromeos_update_engine.DynamicPartitionGroup.partition_names");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DynamicPartitionGroup::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.DynamicPartitionGroup)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "chromeos_update_engine.DynamicPartitionGroup.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional uint64 size = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_size(), target);
  }

  // repeated string partition_names = 3;
  for (int i = 0, n = this->_internal_partition_names_size(); i < n; i++) {
    const auto& s = this->_internal_partition_names(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "chromeos_update_engine.DynamicPartitionGroup.partition_names");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.DynamicPartitionGroup)
  return target;
}

size_t DynamicPartitionGroup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.DynamicPartitionGroup)
  size_t total_size = 0;

  // required string name = 1;
  if (_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string partition_names = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.partition_names_.size());
  for (int i = 0, n = _impl_.partition_names_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.partition_names_.Get(i));
  }

  // optional uint64 size = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DynamicPartitionGroup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DynamicPartitionGroup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DynamicPartitionGroup::GetClassData() const { return &_class_data_; }


void DynamicPartitionGroup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DynamicPartitionGroup*>(&to_msg);
  auto& from = static_cast<const DynamicPartitionGroup&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.DynamicPartitionGroup)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.partition_names_.MergeFrom(from._impl_.partition_names_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DynamicPartitionGroup::CopyFrom(const DynamicPartitionGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.DynamicPartitionGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DynamicPartitionGroup::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void DynamicPartitionGroup::InternalSwap(DynamicPartitionGroup* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.partition_names_.InternalSwap(&other->_impl_.partition_names_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.size_, other->_impl_.size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DynamicPartitionGroup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[7]);
}

// ===================================================================

class VABCFeatureSet::_Internal {
 public:
  using HasBits = decltype(std::declval<VABCFeatureSet>()._impl_._has_bits_);
  static void set_has_threaded(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_batch_writes(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

VABCFeatureSet::VABCFeatureSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.VABCFeatureSet)
}
VABCFeatureSet::VABCFeatureSet(const VABCFeatureSet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VABCFeatureSet* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.threaded_){}
    , decltype(_impl_.batch_writes_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.threaded_, &from._impl_.threaded_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.batch_writes_) -
    reinterpret_cast<char*>(&_impl_.threaded_)) + sizeof(_impl_.batch_writes_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.VABCFeatureSet)
}

inline void VABCFeatureSet::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.threaded_){false}
    , decltype(_impl_.batch_writes_){false}
  };
}

VABCFeatureSet::~VABCFeatureSet() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.VABCFeatureSet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VABCFeatureSet::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VABCFeatureSet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VABCFeatureSet::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.VABCFeatureSet)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.threaded_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.batch_writes_) -
      reinterpret_cast<char*>(&_impl_.threaded_)) + sizeof(_impl_.batch_writes_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VABCFeatureSet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool threaded = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_threaded(&has_bits);
          _impl_.threaded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool batch_writes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_batch_writes(&has_bits);
          _impl_.batch_writes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* VABCFeatureSet::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.VABCFeatureSet)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool threaded = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_threaded(), target);
  }

  // optional bool batch_writes = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_batch_writes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.VABCFeatureSet)
  return target;
}

size_t VABCFeatureSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.VABCFeatureSet)
  size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool threaded = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool batch_writes = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VABCFeatureSet::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VABCFeatureSet::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VABCFeatureSet::GetClassData() const { return &_class_data_; }


void VABCFeatureSet::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VABCFeatureSet*>(&to_msg);
  auto& from = static_cast<const VABCFeatureSet&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.VABCFeatureSet)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.threaded_ = from._impl_.threaded_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.batch_writes_ = from._impl_.batch_writes_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VABCFeatureSet::CopyFrom(const VABCFeatureSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.VABCFeatureSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VABCFeatureSet::IsInitialized() const {
  return true;
}

void VABCFeatureSet::InternalSwap(VABCFeatureSet* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VABCFeatureSet, _impl_.batch_writes_)
      + sizeof(VABCFeatureSet::_impl_.batch_writes_)  // NOLINT
      - PROTOBUF_FIELD_OFFSET(VABCFeatureSet, _impl_.threaded_)>(
          reinterpret_cast<char*>(&_impl_.threaded_),
          reinterpret_cast<char*>(&other->_impl_.threaded_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VABCFeatureSet::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[8]);
}

// ===================================================================

class DynamicPartitionMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<DynamicPartitionMetadata>()._impl_._has_bits_);
  static void set_has_snapshot_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_vabc_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_vabc_compression_param(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cow_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::chromeos_update_engine::VABCFeatureSet& vabc_feature_set(const DynamicPartitionMetadata* msg);
  static void set_has_vabc_feature_set(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_compression_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::chromeos_update_engine::VABCFeatureSet&
DynamicPartitionMetadata::_Internal::vabc_feature_set(const DynamicPartitionMetadata* msg) {
  return *msg->_impl_.vabc_feature_set_;
}
DynamicPartitionMetadata::DynamicPartitionMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.DynamicPartitionMetadata)
}
DynamicPartitionMetadata::DynamicPartitionMetadata(const DynamicPartitionMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DynamicPartitionMetadata* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.groups_){from._impl_.groups_}
    , decltype(_impl_.vabc_compression_param_){}
    , decltype(_impl_.vabc_feature_set_){nullptr}
    , decltype(_impl_.snapshot_enabled_){}
    , decltype(_impl_.vabc_enabled_){}
    , decltype(_impl_.cow_version_){}
    , decltype(_impl_.compression_factor_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.vabc_compression_param_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vabc_compression_param_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vabc_compression_param()) {
    _this->_impl_.vabc_compression_param_.Set(from._internal_vabc_compression_param(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_vabc_feature_set()) {
    _this->_impl_.vabc_feature_set_ = new ::chromeos_update_engine::VABCFeatureSet(*from._impl_.vabc_feature_set_);
  }
  ::memcpy(&_impl_.snapshot_enabled_, &from._impl_.snapshot_enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.compression_factor_) -
    reinterpret_cast<char*>(&_impl_.snapshot_enabled_)) + sizeof(_impl_.compression_factor_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.DynamicPartitionMetadata)
}

inline void DynamicPartitionMetadata::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.groups_){arena}
    , decltype(_impl_.vabc_compression_param_){}
    , decltype(_impl_.vabc_feature_set_){nullptr}
    , decltype(_impl_.snapshot_enabled_){false}
    , decltype(_impl_.vabc_enabled_){false}
    , decltype(_impl_.cow_version_){0u}
    , decltype(_impl_.compression_factor_){::uint64_t{0u}}
  };
  _impl_.vabc_compression_param_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vabc_compression_param_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DynamicPartitionMetadata::~DynamicPartitionMetadata() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.DynamicPartitionMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DynamicPartitionMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.groups_.~RepeatedPtrField();
  _impl_.vabc_compression_param_.Destroy();
  if (this != internal_default_instance()) delete _impl_.vabc_feature_set_;
}

void DynamicPartitionMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DynamicPartitionMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.DynamicPartitionMetadata)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.groups_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.vabc_compression_param_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.vabc_feature_set_ != nullptr);
      _impl_.vabc_feature_set_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.snapshot_enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.compression_factor_) -
        reinterpret_cast<char*>(&_impl_.snapshot_enabled_)) + sizeof(_impl_.compression_factor_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DynamicPartitionMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_groups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool snapshot_enabled = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_snapshot_enabled(&has_bits);
          _impl_.snapshot_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool vabc_enabled = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_vabc_enabled(&has_bits);
          _impl_.vabc_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string vabc_compression_param = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_vabc_compression_param();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 cow_version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_cow_version(&has_bits);
          _impl_.cow_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_vabc_feature_set(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 compression_factor = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_compression_factor(&has_bits);
          _impl_.compression_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DynamicPartitionMetadata::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.DynamicPartitionMetadata)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_groups_size()); i < n; i++) {
    const auto& repfield = this->_internal_groups(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool snapshot_enabled = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_snapshot_enabled(), target);
  }

  // optional bool vabc_enabled = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_vabc_enabled(), target);
  }

  // optional string vabc_compression_param = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_vabc_compression_param().data(), static_cast<int>(this->_internal_vabc_compression_param().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_vabc_compression_param(), target);
  }

  // optional uint32 cow_version = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_cow_version(), target);
  }

  // optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::vabc_feature_set(this),
        _Internal::vabc_feature_set(this).GetCachedSize(), target, stream);
  }

  // optional uint64 compression_factor = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_compression_factor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.DynamicPartitionMetadata)
  return target;
}

size_t DynamicPartitionMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.DynamicPartitionMetadata)
  size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
  total_size += 1UL * this->_internal_groups_size();
  for (const auto& msg : this->_impl_.groups_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string vabc_compression_param = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_vabc_compression_param());
    }

    // optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vabc_feature_set_);
    }

    // optional bool snapshot_enabled = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool vabc_enabled = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional uint32 cow_version = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cow_version());
    }

    // optional uint64 compression_factor = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_compression_factor());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DynamicPartitionMetadata::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DynamicPartitionMetadata::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DynamicPartitionMetadata::GetClassData() const { return &_class_data_; }


void DynamicPartitionMetadata::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DynamicPartitionMetadata*>(&to_msg);
  auto& from = static_cast<const DynamicPartitionMetadata&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.DynamicPartitionMetadata)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.groups_.MergeFrom(from._impl_.groups_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_vabc_compression_param(from._internal_vabc_compression_param());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_vabc_feature_set()->::chromeos_update_engine::VABCFeatureSet::MergeFrom(
          from._internal_vabc_feature_set());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.snapshot_enabled_ = from._impl_.snapshot_enabled_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.vabc_enabled_ = from._impl_.vabc_enabled_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.cow_version_ = from._impl_.cow_version_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.compression_factor_ = from._impl_.compression_factor_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DynamicPartitionMetadata::CopyFrom(const DynamicPartitionMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.DynamicPartitionMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DynamicPartitionMetadata::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.groups_))
    return false;
  return true;
}

void DynamicPartitionMetadata::InternalSwap(DynamicPartitionMetadata* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.groups_.InternalSwap(&other->_impl_.groups_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vabc_compression_param_, lhs_arena,
      &other->_impl_.vabc_compression_param_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DynamicPartitionMetadata, _impl_.compression_factor_)
      + sizeof(DynamicPartitionMetadata::_impl_.compression_factor_)  // NOLINT
      - PROTOBUF_FIELD_OFFSET(DynamicPartitionMetadata, _impl_.vabc_feature_set_)>(
          reinterpret_cast<char*>(&_impl_.vabc_feature_set_),
          reinterpret_cast<char*>(&other->_impl_.vabc_feature_set_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DynamicPartitionMetadata::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[9]);
}

// ===================================================================

class ApexInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ApexInfo>()._impl_._has_bits_);
  static void set_has_package_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_compressed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_decompressed_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ApexInfo::ApexInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.ApexInfo)
}
ApexInfo::ApexInfo(const ApexInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ApexInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.package_name_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.decompressed_size_){}
    , decltype(_impl_.is_compressed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.package_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.package_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_package_name()) {
    _this->_impl_.package_name_.Set(from._internal_package_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.version_, &from._impl_.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_compressed_) -
    reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.is_compressed_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.ApexInfo)
}

inline void ApexInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.package_name_){}
    , decltype(_impl_.version_){::int64_t{0}}
    , decltype(_impl_.decompressed_size_){::int64_t{0}}
    , decltype(_impl_.is_compressed_){false}
  };
  _impl_.package_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.package_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ApexInfo::~ApexInfo() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.ApexInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApexInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.package_name_.Destroy();
}

void ApexInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ApexInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.ApexInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.package_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_compressed_) -
        reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.is_compressed_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApexInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string package_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_package_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "chromeos_update_engine.ApexInfo.package_name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool is_compressed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_is_compressed(&has_bits);
          _impl_.is_compressed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 decompressed_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_decompressed_size(&has_bits);
          _impl_.decompressed_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ApexInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.ApexInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string package_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_package_name().data(), static_cast<int>(this->_internal_package_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "chromeos_update_engine.ApexInfo.package_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_package_name(), target);
  }

  // optional int64 version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_version(), target);
  }

  // optional bool is_compressed = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_compressed(), target);
  }

  // optional int64 decompressed_size = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_decompressed_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.ApexInfo)
  return target;
}

size_t ApexInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.ApexInfo)
  size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string package_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_package_name());
    }

    // optional int64 version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_version());
    }

    // optional int64 decompressed_size = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_decompressed_size());
    }

    // optional bool is_compressed = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApexInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ApexInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApexInfo::GetClassData() const { return &_class_data_; }


void ApexInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ApexInfo*>(&to_msg);
  auto& from = static_cast<const ApexInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.ApexInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_package_name(from._internal_package_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.decompressed_size_ = from._impl_.decompressed_size_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_compressed_ = from._impl_.is_compressed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApexInfo::CopyFrom(const ApexInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.ApexInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApexInfo::IsInitialized() const {
  return true;
}

void ApexInfo::InternalSwap(ApexInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.package_name_, lhs_arena,
      &other->_impl_.package_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ApexInfo, _impl_.is_compressed_)
      + sizeof(ApexInfo::_impl_.is_compressed_)  // NOLINT
      - PROTOBUF_FIELD_OFFSET(ApexInfo, _impl_.version_)>(
          reinterpret_cast<char*>(&_impl_.version_),
          reinterpret_cast<char*>(&other->_impl_.version_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ApexInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[10]);
}

// ===================================================================

class ApexMetadata::_Internal {
 public:
};

ApexMetadata::ApexMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.ApexMetadata)
}
ApexMetadata::ApexMetadata(const ApexMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ApexMetadata* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.apex_info_){from._impl_.apex_info_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.ApexMetadata)
}

inline void ApexMetadata::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.apex_info_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ApexMetadata::~ApexMetadata() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.ApexMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApexMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.apex_info_.~RepeatedPtrField();
}

void ApexMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ApexMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.ApexMetadata)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.apex_info_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApexMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .chromeos_update_engine.ApexInfo apex_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_apex_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ApexMetadata::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.ApexMetadata)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.ApexInfo apex_info = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_apex_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_apex_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.ApexMetadata)
  return target;
}

size_t ApexMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.ApexMetadata)
  size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.ApexInfo apex_info = 1;
  total_size += 1UL * this->_internal_apex_info_size();
  for (const auto& msg : this->_impl_.apex_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApexMetadata::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ApexMetadata::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApexMetadata::GetClassData() const { return &_class_data_; }


void ApexMetadata::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ApexMetadata*>(&to_msg);
  auto& from = static_cast<const ApexMetadata&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.ApexMetadata)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.apex_info_.MergeFrom(from._impl_.apex_info_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApexMetadata::CopyFrom(const ApexMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.ApexMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApexMetadata::IsInitialized() const {
  return true;
}

void ApexMetadata::InternalSwap(ApexMetadata* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.apex_info_.InternalSwap(&other->_impl_.apex_info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ApexMetadata::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[11]);
}

// ===================================================================

class DeltaArchiveManifest::_Internal {
 public:
  using HasBits = decltype(std::declval<DeltaArchiveManifest>()._impl_._has_bits_);
  static void set_has_block_size(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_signatures_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_signatures_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_minor_version(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_max_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::chromeos_update_engine::DynamicPartitionMetadata& dynamic_partition_metadata(const DeltaArchiveManifest* msg);
  static void set_has_dynamic_partition_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_partial_update(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_security_patch_level(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::chromeos_update_engine::DynamicPartitionMetadata&
DeltaArchiveManifest::_Internal::dynamic_partition_metadata(const DeltaArchiveManifest* msg) {
  return *msg->_impl_.dynamic_partition_metadata_;
}
DeltaArchiveManifest::DeltaArchiveManifest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:chromeos_update_engine.DeltaArchiveManifest)
}
DeltaArchiveManifest::DeltaArchiveManifest(const DeltaArchiveManifest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeltaArchiveManifest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.partitions_){from._impl_.partitions_}
    , decltype(_impl_.apex_info_){from._impl_.apex_info_}
    , decltype(_impl_.security_patch_level_){}
    , decltype(_impl_.dynamic_partition_metadata_){nullptr}
    , decltype(_impl_.signatures_offset_){}
    , decltype(_impl_.signatures_size_){}
    , decltype(_impl_.max_timestamp_){}
    , decltype(_impl_.minor_version_){}
    , decltype(_impl_.partial_update_){}
    , decltype(_impl_.block_size_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.security_patch_level_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.security_patch_level_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_security_patch_level()) {
    _this->_impl_.security_patch_level_.Set(from._internal_security_patch_level(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_dynamic_partition_metadata()) {
    _this->_impl_.dynamic_partition_metadata_ = new ::chromeos_update_engine::DynamicPartitionMetadata(*from._impl_.dynamic_partition_metadata_);
  }
  ::memcpy(&_impl_.signatures_offset_, &from._impl_.signatures_offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.block_size_) -
    reinterpret_cast<char*>(&_impl_.signatures_offset_)) + sizeof(_impl_.block_size_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.DeltaArchiveManifest)
}

inline void DeltaArchiveManifest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.partitions_){arena}
    , decltype(_impl_.apex_info_){arena}
    , decltype(_impl_.security_patch_level_){}
    , decltype(_impl_.dynamic_partition_metadata_){nullptr}
    , decltype(_impl_.signatures_offset_){::uint64_t{0u}}
    , decltype(_impl_.signatures_size_){::uint64_t{0u}}
    , decltype(_impl_.max_timestamp_){::int64_t{0}}
    , decltype(_impl_.minor_version_){0u}
    , decltype(_impl_.partial_update_){false}
    , decltype(_impl_.block_size_){4096u}
  };
  _impl_.security_patch_level_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.security_patch_level_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeltaArchiveManifest::~DeltaArchiveManifest() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.DeltaArchiveManifest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeltaArchiveManifest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.partitions_.~RepeatedPtrField();
  _impl_.apex_info_.~RepeatedPtrField();
  _impl_.security_patch_level_.Destroy();
  if (this != internal_default_instance()) delete _impl_.dynamic_partition_metadata_;
}

void DeltaArchiveManifest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeltaArchiveManifest::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.DeltaArchiveManifest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.partitions_.Clear();
  _impl_.apex_info_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.security_patch_level_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.dynamic_partition_metadata_ != nullptr);
      _impl_.dynamic_partition_metadata_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.signatures_offset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.partial_update_) -
        reinterpret_cast<char*>(&_impl_.signatures_offset_)) + sizeof(_impl_.partial_update_));
    _impl_.block_size_ = 4096u;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeltaArchiveManifest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 block_size = 3 [default = 4096];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_block_size(&has_bits);
          _impl_.block_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 signatures_offset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_signatures_offset(&has_bits);
          _impl_.signatures_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 signatures_size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_signatures_size(&has_bits);
          _impl_.signatures_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 minor_version = 12 [default = 0];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
          _Internal::set_has_minor_version(&has_bits);
          _impl_.minor_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_partitions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 max_timestamp = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _Internal::set_has_max_timestamp(&has_bits);
          _impl_.max_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_dynamic_partition_metadata(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool partial_update = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _Internal::set_has_partial_update(&has_bits);
          _impl_.partial_update_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .chromeos_update_engine.ApexInfo apex_info = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 138)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_apex_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<138>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string security_patch_level = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 146)) {
          auto str = _internal_mutable_security_patch_level();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "chromeos_update_engine.DeltaArchiveManifest.security_patch_level");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DeltaArchiveManifest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chromeos_update_engine.DeltaArchiveManifest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 block_size = 3 [default = 4096];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_block_size(), target);
  }

  // optional uint64 signatures_offset = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_signatures_offset(), target);
  }

  // optional uint64 signatures_size = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_signatures_size(), target);
  }

  // optional uint32 minor_version = 12 [default = 0];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_minor_version(), target);
  }

  // repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_partitions_size()); i < n; i++) {
    const auto& repfield = this->_internal_partitions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int64 max_timestamp = 14;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(14, this->_internal_max_timestamp(), target);
  }

  // optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::dynamic_partition_metadata(this),
        _Internal::dynamic_partition_metadata(this).GetCachedSize(), target, stream);
  }

  // optional bool partial_update = 16;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_partial_update(), target);
  }

  // repeated .chromeos_update_engine.ApexInfo apex_info = 17;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_apex_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_apex_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(17, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string security_patch_level = 18;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_security_patch_level().data(), static_cast<int>(this->_internal_security_patch_level().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "chromeos_update_engine.DeltaArchiveManifest.security_patch_level");
    target = stream->WriteStringMaybeAliased(
        18, this->_internal_security_patch_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chromeos_update_engine.DeltaArchiveManifest)
  return target;
}

size_t DeltaArchiveManifest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.DeltaArchiveManifest)
  size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
  total_size += 1UL * this->_internal_partitions_size();
  for (const auto& msg : this->_impl_.partitions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .chromeos_update_engine.ApexInfo apex_info = 17;
  total_size += 2UL * this->_internal_apex_info_size();
  for (const auto& msg : this->_impl_.apex_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string security_patch_level = 18;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_security_patch_level());
    }

    // optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dynamic_partition_metadata_);
    }

    // optional uint64 signatures_offset = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_signatures_offset());
    }

    // optional uint64 signatures_size = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_signatures_size());
    }

    // optional int64 max_timestamp = 14;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_max_timestamp());
    }

    // optional uint32 minor_version = 12 [default = 0];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_minor_version());
    }

    // optional bool partial_update = 16;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + 1;
    }

    // optional uint32 block_size = 3 [default = 4096];
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_block_size());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeltaArchiveManifest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeltaArchiveManifest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeltaArchiveManifest::GetClassData() const { return &_class_data_; }


void DeltaArchiveManifest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeltaArchiveManifest*>(&to_msg);
  auto& from = static_cast<const DeltaArchiveManifest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.DeltaArchiveManifest)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.partitions_.MergeFrom(from._impl_.partitions_);
  _this->_impl_.apex_info_.MergeFrom(from._impl_.apex_info_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_security_patch_level(from._internal_security_patch_level());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_dynamic_partition_metadata()->::chromeos_update_engine::DynamicPartitionMetadata::MergeFrom(
          from._internal_dynamic_partition_metadata());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.signatures_offset_ = from._impl_.signatures_offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.signatures_size_ = from._impl_.signatures_size_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.max_timestamp_ = from._impl_.max_timestamp_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.minor_version_ = from._impl_.minor_version_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.partial_update_ = from._impl_.partial_update_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.block_size_ = from._impl_.block_size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeltaArchiveManifest::CopyFrom(const DeltaArchiveManifest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.DeltaArchiveManifest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeltaArchiveManifest::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.partitions_))
    return false;
  if (_internal_has_dynamic_partition_metadata()) {
    if (!_impl_.dynamic_partition_metadata_->IsInitialized()) return false;
  }
  return true;
}

void DeltaArchiveManifest::InternalSwap(DeltaArchiveManifest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.partitions_.InternalSwap(&other->_impl_.partitions_);
  _impl_.apex_info_.InternalSwap(&other->_impl_.apex_info_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.security_patch_level_, lhs_arena,
      &other->_impl_.security_patch_level_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeltaArchiveManifest, _impl_.partial_update_)
      + sizeof(DeltaArchiveManifest::_impl_.partial_update_)  // NOLINT
      - PROTOBUF_FIELD_OFFSET(DeltaArchiveManifest, _impl_.dynamic_partition_metadata_)>(
          reinterpret_cast<char*>(&_impl_.dynamic_partition_metadata_),
          reinterpret_cast<char*>(&other->_impl_.dynamic_partition_metadata_));
  swap(_impl_.block_size_, other->_impl_.block_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeltaArchiveManifest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_update_5fmetadata_2eproto_getter, &descriptor_table_update_5fmetadata_2eproto_once,
      file_level_metadata_update_5fmetadata_2eproto[12]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace chromeos_update_engine
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::Extent*
Arena::CreateMaybeMessage< ::chromeos_update_engine::Extent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::Extent >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::Signatures_Signature*
Arena::CreateMaybeMessage< ::chromeos_update_engine::Signatures_Signature >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::Signatures_Signature >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::Signatures*
Arena::CreateMaybeMessage< ::chromeos_update_engine::Signatures >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::Signatures >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::PartitionInfo*
Arena::CreateMaybeMessage< ::chromeos_update_engine::PartitionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::PartitionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::InstallOperation*
Arena::CreateMaybeMessage< ::chromeos_update_engine::InstallOperation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::InstallOperation >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::CowMergeOperation*
Arena::CreateMaybeMessage< ::chromeos_update_engine::CowMergeOperation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::CowMergeOperation >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::PartitionUpdate*
Arena::CreateMaybeMessage< ::chromeos_update_engine::PartitionUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::PartitionUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::DynamicPartitionGroup*
Arena::CreateMaybeMessage< ::chromeos_update_engine::DynamicPartitionGroup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::DynamicPartitionGroup >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::VABCFeatureSet*
Arena::CreateMaybeMessage< ::chromeos_update_engine::VABCFeatureSet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::VABCFeatureSet >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::DynamicPartitionMetadata*
Arena::CreateMaybeMessage< ::chromeos_update_engine::DynamicPartitionMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::DynamicPartitionMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::ApexInfo*
Arena::CreateMaybeMessage< ::chromeos_update_engine::ApexInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::ApexInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::ApexMetadata*
Arena::CreateMaybeMessage< ::chromeos_update_engine::ApexMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::ApexMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::DeltaArchiveManifest*
Arena::CreateMaybeMessage< ::chromeos_update_engine::DeltaArchiveManifest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chromeos_update_engine::DeltaArchiveManifest >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
